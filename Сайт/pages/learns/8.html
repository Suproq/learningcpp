<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Указатели</title>
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
    <link rel="stylesheet"
      href="prism.css">
    <script src="../../scripts/prism.js"></script>
  </head>
  <body>
    <div class="wrapper">
    <header>
        <ul class="headbut">
          <li><a href="../../index.html"><div>Главная</div></a></li>
          <li><a class="active" href="../learns.html"><div>Уроки</div></a></li>
          <li><a href="../tasks.html"><div>Задачи</div></a></li>
          <li><a href="../about.html"><div>О нас</div></a></li>
        </ul>
    </header>
    <div class="content">
        <div style="padding: 1% 3%;">
            <div class="upbut">
                <a style="float: left;" href="7.html">Назад</a>
                <a style="margin-left: auto;" href="9.html">Следующий урок</a>
            </div>
            <h1>Урок 8: Указатели</h1>
            <p>Сегодня мы поговорим о функциях в C++. Очень часто в программировании необходимо выполнять одни и те же действия. Например, мы хотим выводить пользователю сообщения об ошибке в разных местах программы, если он ввел неверное значение. без функций это выглядело бы так: </p>
            <pre class="line-numbers"><code class="language-clike">#include &lt;iostream>
#include <string>

using namespace std;

int main()
{    
    string valid_pass = "qwerty123";
    string user_pass;
    cout << "Введите пароль: ";
    getline(cin, user_pass);
    if (user_pass == valid_pass) {
        cout << "Доступ разрешен." << endl;
    } else {
        cout << "Неверный пароль!" << endl;
    }
    return 0;    
}</code></pre>
           <p>При выполнении любой программы, все необходимые для ее работы данные должныбыть загружены в оперативную память компьютера. Для обращения к переменным, находящимся в памяти, используются специальные адреса, которые записываются в шестнадцатеричном виде, например 0x100 или 0x200.</p>
           <p>Если переменных в памяти потребуется слишком большое количество, которое не сможет вместить в себя сама аппаратная часть, произойдет перегрузка системы или её зависание. </p>
           <p>Если мы объявляем переменные статично, так как мы делали в предыдущих уроках, они остаются в памяти до того момента, как программа завершит свою работу, а после чего уничтожаются.</p>
           <p>Такой подход может быть приемлем в простых примерах и несложных программах, которые не требуют большого количества ресурсов. Если же наш проект является огромным программным комплексом с высоким функционалом, объявлять таким образом переменные, естественно, было бы довольно не умно.</p>
           <p>Можете себе представить, если бы небезызвестная Battlefield 3 использовала такой метод работы с данными? В таком случае, самым заядлым геймерам пришлось бы перезагружать свои высоконагруженные системы кнопкой reset после нескольких секунд работы игры.</p>
           <p>Дело в том, что играя в тот же Battlefield, геймер в каждый новый момент времени видит различные объекты на экране монитора, например сейчас я стреляю во врага, а через долю секунды он уже падает убитым, создавая вокруг себя множество спецэффектов, таких как пыль, тени, и т.п.</p>
           <p>Естественно, все это занимает какое-то место в оперативной памяти компьютера. Если не уничтожать неиспользуемые объекты, очень скоро они заполнят весь объем ресурсов ПК.</p>
           <p>По этим причинам, в большинстве языков, в том числе и C/C++, имеется понятие указателя. Указатель — это переменная, хранящая в себе адрес ячейки оперативной памяти, например 0x100.</p>
           <p>Мы можем обращаться, например к массиву данных через указатель, который будет содержать адрес начала диапазона ячеек памяти, хранящих этот массив.</p>
           <p>После того, как этот массив станет не нужен для выполнения остальной части программы, мы просто освободим память по адресу этого указателя, и она вновь станет доступно для других переменных.</p>
           <p>Ниже приведен конкретный пример обращения к переменным через указатель и напрямую.</p>
           <pre class="line-numbers"><code class="language-clike">//Используются статические переменные
#include &lt;iostream>
using namespace std;

int main()
{
    int a; // Объявление статической переменной
    int b = 5; // Инициализация статической переменной b

    a = 10;
    b = a + b;
    cout << "b is " << b << endl;
    return 0;
}</code></pre>
    <pre class="line-numbers"><code class="language-clike">//Используются динамические переменные
#include &lt;iostream>
using namespace std;

int main()
{
    int *a = new int; // Объявление указателя для переменной типа int
    int *b = new int(5); // Инициализация указателя

    *a = 10;
    *b = *a + *b;

    cout << "b is " << *b << endl;

    delete b;
    delete a;

    return 0;
}</code></pre>
    <p>Синтаксис первого примера вам уже должен быть знаком. Мы объявляем/инициализируем статичные переменные <code class="language-clike">a</code> и <code class="language-clike">b</code>, после чего выполняем различные операции напрямую с ними.</p>
    <p>Во втором примере мы оперируем динамическими переменными посредством указателей. Рассмотрим общий синтаксис указателей в C++.</p>
    <p>Выделение памяти осуществляется с помощью оператора <code class="language-clike">new</code> и имеет вид: тип_данных <code class="language-clike">*имя_указателя = new тип_данных;</code>, например <code class="language-clike">int *a = new int;</code>. После удачного выполнения такой операции, в оперативной памяти компьютера происходит выделение диапазона ячеек, необходимого для хранения переменной типа <code class="language-clike">int</code>.</p>
    <p>Логично предположить, что для разных типов данных выделяется разное количество памяти. Следует быть особенно осторожным при работе с памятью, потому что именно ошибки программы, вызванные утечкой памяти, являются одними из самых трудно находимых. На отладку программы в поисках одной ничтожной ошибки, может уйти час, день, неделя, в зависимости от упорности разработчика и объема кода.</p>
    <p>Инициализация значения, находящегося по адресу указателя выполняется схожим образом, только в конце ставятся круглые скобки с нужным значением: <code class="language-clike">тип данных *имя_указателя = new тип_данных(значение)</code>. В нашем примере это <code class="language-clike">int *b = new int(5)</code>.</p>
    <p>Для того, чтобы получить адрес в памяти, на который ссылается указатель, используется имя переменной-указателя с префиксом <code class="language-clike">&</code>. перед ним(не путать со знаком ссылки в C++).</p>
    <p>Например, чтобы вывести на экран адрес ячейки памяти, на который ссылается указатель b во втором примере, мы пишем <code class="language-clike">cout << "Address of b is " << &b << endl;</code>. В моей системе, я получил значение 0x1aba030. У вас оно может быть другим, потому что адреса в оперативной памяти распределяются таким образом, чтобы максимально уменьшить фрагментацию. Поскольку, в любой системе список запущенных процессов, а также объем и разрядность памяти могут отличаться, система сама распределяет данные для обеспечения минимальной фрагментации.  </p>
    <p>Для того, чтобы получить значение, которое находится по адресу, на который ссылается указатель, используется префикс *. Данная операция называется разыменованием указателя.</p>
    <p>Во втором примере мы выводим на экран значение, которое находится в ячейке памяти (у меня это 0x1aba030): <code class="language-clike">cout << "b is " << *b << endl;</code> . В этом случае необходимо использовать знак *.</p>
    <p>Чтобы изменить значение, находящееся по адресу, на который ссылается указатель, нужно также использовать звездочку, например, как во втором примере — <code class="language-clike">*b = *a + *b;</code>.</p>
    <ul>
      <li>Когда мы оперируем данными, то используем знак *</li>
      <li>Когда мы оперируем адресами, то используем знак &</li>
    </ul>
    <p>В этих вещах очень часто возникают недопонимания, и кстати, не только у новичков. Многие из тех, кто начинал программировать с того же php, также часто испытывают подобную путаницу при работе с памятью.</p>
    <p>Для того, чтобы освободить память, выделенную оператором new, используется оператор delete.</p>
    <pre class="line-numbers"><code class="language-clike">#include &lt;iostream>
using namespace std;

int main()
{
    // Выделение памяти
    int *a = new int;
    int *b = new int;
    float *c = new float;

    // ... Любые действия программы

    // Освобождение выделенной памяти
    delete c;
    delete b;
    delete a;

    return 0;
}</code></pre>
    <p>При использовании оператора delete для указателя, знак * не используется.</p>
    <div class="buttons">
        <a href="7.html">Назад</a>
        <a href="9.html">Следующий урок</a>
      </div>
        </div>
    </div>
    <footer>
        <p>©2022</p>
      </footer>
    </div>
  </body>
</html>